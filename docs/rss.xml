<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://captain0005.github.io/captain</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://captain0005.github.io/captain</link></image><lastBuildDate>Thu, 20 Nov 2025 07:46:16 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>Async-HttpServer 异步http服务</title><link>https://captain0005.github.io/captain/post/Async-HttpServer%20-yi-bu-http-fu-wu.html</link><description>```
#include &lt;boost/asio.hpp&gt;
#include &lt;boost/beast.hpp&gt;
#include &lt;boost/json.hpp&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;boost/thread.hpp&gt;
#include &lt;csignal&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

namespace asio = boost::asio;
namespace beast = boost::beast;
namespace http = beast::http;
namespace json = boost::json;
using tcp = asio::ip::tcp;

// 全局标志，用于控制服务器退出
volatile std::sig_atomic_t g_running = true;

// 信号处理函数
void signalHandler(int signal) {
    std::cout &lt;&lt; 'Received signal ' &lt;&lt; signal &lt;&lt; ', shutting down...' &lt;&lt; std::endl;
    g_running = false;
}

// 定义处理器函数类型
typedef std::function&lt;void(const http::request&lt;http::string_body&gt;&amp;, http::response&lt;http::string_body&gt;&amp;)&gt; RequestHandler;

// 路由管理器类，用于注册和查找路由
class Router {
private:
    std::map&lt;std::string, RequestHandler&gt; routes;
    std::string getRouteKey(http::verb method, const std::string&amp; target) {
        return std::to_string(static_cast&lt;int&gt;(method)) + ':' + target;
    }
public:
    void registerRoute(http::verb method, const std::string&amp; target, RequestHandler handler) {
        std::string key = getRouteKey(method, target);
        routes[key] = handler;
    }
    bool handleRequest(const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        std::string key = getRouteKey(req.method(), std::string(req.target()));
        auto it = routes.find(key);
        if (it != routes.end()) {
            it-&gt;second(req, res);
            return true;
        }
        return false;
    }
};

// 全局路由管理器实例
Router g_router;

// 初始化路由表
void initializeRoutes() {
    g_router.registerRoute(http::verb::get, '/status', [](const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        json::object response_json;
        response_json['status'] = 'Server is running!';
        res.result(http::status::ok);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    });

    g_router.registerRoute(http::verb::post, '/greet', [](const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        json::object response_json;
        try {
            json::value parsed_body = json::parse(req.body());
            std::string name = parsed_body.as_object()['name'].as_string().c_str();
            response_json['message'] = 'Hello, ' + name + '!';
        } catch (...) {
            response_json['error'] = 'Invalid JSON format.';
        }
        res.result(http::status::ok);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    });
    // 可以根据需要继续添加更多路由...
}

// 处理请求的函数
void handle_request(
    http::request&lt;http::string_body&gt; req,
    http::response&lt;http::string_body&gt;&amp; res
) {
    json::object response_json;
    std::cout &lt;&lt; 'Method: ' &lt;&lt; req.method() &lt;&lt; '...\n';
    std::cout &lt;&lt; 'Target: ' &lt;&lt; req.target() &lt;&lt; '...\n';
    std::cout &lt;&lt; 'Body: ' &lt;&lt; req.body() &lt;&lt; '...\n\n';
    if (!g_router.handleRequest(req, res)) {
        response_json['error'] = 'Unknown endpoint.';
        res.result(http::status::not_found);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    }
}

// 异步会话类
class Session : public std::enable_shared_from_this&lt;Session&gt; {
public:
    Session(tcp::socket socket)
        : socket_(std::move(socket)) {}

    void start() {
        do_read();
    }

private:
    tcp::socket socket_;
    beast::flat_buffer buffer_;
    http::request&lt;http::string_body&gt; req_;

    void do_read() {
        auto self = shared_from_this();
        http::async_read(socket_, buffer_, req_,
            [self](beast::error_code ec, std::size_t) {
                if (!ec) {
                    self-&gt;handle_request();
                }
                // 连接关闭由客户端控制，或可在此处关闭
            });
    }

    void handle_request() {
        http::response&lt;http::string_body&gt; res;
        ::handle_request(req_, res);

        auto self = shared_from_this();
        http::async_write(socket_, res,
            [self](beast::error_code ec, std::size_t) {
                beast::error_code ignore_ec;
                self-&gt;socket_.shutdown(tcp::socket::shutdown_send, ignore_ec);
                // 会话对象自动析构
            });
    }
};

// 异步accept
void do_accept(asio::io_context&amp; ioc, tcp::acceptor&amp; acceptor) {
    acceptor.async_accept(
        [&amp;ioc, &amp;acceptor](beast::error_code ec, tcp::socket socket) {
            if (!ec) {
                std::make_shared&lt;Session&gt;(std::move(socket))-&gt;start();
            }
            if (g_running) {
                do_accept(ioc, acceptor);
            }
        }
    );
}

// 异步服务器主函数
void run_server(asio::io_context&amp; ioc, unsigned short port, unsigned int thread_pool_size) {
    tcp::acceptor acceptor(ioc, tcp::endpoint(tcp::v4(), port));
    do_accept(ioc, acceptor);

    std::cout &lt;&lt; 'HTTP Server running on port ' &lt;&lt; port &lt;&lt; '...\n\n';
    std::vector&lt;std::thread&gt; threads;
    for (unsigned int i = 0; i &lt; thread_pool_size; ++i) {
        threads.emplace_back([&amp;ioc]() { ioc.run(); });
    }
    for (auto&amp; t : threads) t.join();
    std::cout &lt;&lt; 'Server shutdown complete\n';
}

int main() {
    try {
        std::signal(SIGINT, signalHandler);
        std::signal(SIGTERM, signalHandler);

        initializeRoutes();
        asio::io_context io_context;

        unsigned int thread_pool_size = std::thread::hardware_concurrency();
        if (thread_pool_size == 0)
            thread_pool_size = 4;
        run_server(io_context, 8080, thread_pool_size);
    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; 'Server error: ' &lt;&lt; e.what() &lt;&lt; '\n';
    }
    return 0;
}
```
###run_server函数是异步HTTP服务器的核心启动与管理函数，主要功能如下：

**服务器初始化与启动：**

创建TCP acceptor并绑定到指定的IPv4端口
调用do_accept函数启动异步连接接受循环，使服务器能够非阻塞地接受新连接
输出服务器启动信息，指示服务器正在哪个端口运行
**线程池创建与管理：**

创建std::vector&lt;std::thread&gt;容器来管理工作线程池
根据thread_pool_size参数，创建指定数量的工作线程
每个线程都运行io_context.run()，启动I/O事件循环
选中的代码行threads.emplace_back([&amp;ioc]() { ioc.run(); });创建一个新线程并捕获io_context引用，使该线程开始处理异步操作队列
**服务器生命周期管理：**

使用join()等待所有工作线程完成，确保服务器优雅关闭
线程池中的所有线程共享同一个io_context实例，协同处理异步事件
当io_context停止时（通常由信号处理器设置g_running=false触发），所有线程会退出其事件循环
输出服务器关闭完成的信息
**工作原理：**

这种设计采用了Boost.Asio的'线程池 + 单io_context'模式，提高了服务器处理并发请求的能力
主线程负责初始化和等待，而工作线程处理实际的网络I/O事件
异步接受连接和异步处理请求相结合，实现了高性能的非阻塞服务器架构
该函数是整个异步HTTP服务器的骨架，通过线程池机制充分利用多核CPU资源，同时保持异步非阻塞的高效特性。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/Async-HttpServer%20-yi-bu-http-fu-wu.html</guid><pubDate>Thu, 20 Nov 2025 07:45:46 +0000</pubDate></item><item><title>Boost Http服务端-同步方式</title><link>https://captain0005.github.io/captain/post/Boost%20Http-fu-wu-duan---tong-bu-fang-shi.html</link><description>```
#include &lt;boost/asio.hpp&gt;
#include &lt;boost/beast.hpp&gt;
#include &lt;boost/json.hpp&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;boost/thread.hpp&gt;
namespace asio = boost::asio;
namespace beast = boost::beast;
namespace http = beast::http;
namespace json = boost::json;
using tcp = asio::ip::tcp;


// 全局标志，用于控制服务器退出
volatile std::sig_atomic_t g_running = true;

// 信号处理函数
void signalHandler(int signal) {
    std::cout &lt;&lt; 'Received signal ' &lt;&lt; signal &lt;&lt; ', shutting down...' &lt;&lt; std::endl;
    g_running = false;
}

// 定义处理器函数类型
typedef std::function&lt;void(const http::request&lt;http::string_body&gt;&amp;, http::response&lt;http::string_body&gt;&amp;)&gt; RequestHandler;


// 路由管理器类，用于注册和查找路由
class Router {
private:
    // 路由表，键为HTTP方法+路径，值为对应的处理函数
    std::map&lt;std::string, RequestHandler&gt; routes;
    
    // 生成路由键
    std::string getRouteKey(http::verb method, const std::string&amp; target) {
        return std::to_string(static_cast&lt;int&gt;(method)) + ':' + target;
    }
    
public:
    // 注册路由
    void registerRoute(http::verb method, const std::string&amp; target, RequestHandler handler) {
        std::string key = getRouteKey(method, target);
        routes[key] = handler;
    }
    
    // 查找并执行路由处理函数
    bool handleRequest(const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        std::string key = getRouteKey(req.method(), std::string(req.target()));
        
        auto it = routes.find(key);
        if (it != routes.end()) {
            // 找到对应的处理函数，执行它
            it-&gt;second(req, res);
            return true;
        }
        
        return false; // 未找到匹配的路由
    }
};

// 全局路由管理器实例
Router g_router;

// 初始化路由表
void initializeRoutes() {
    // 注册GET /status路由
    g_router.registerRoute(http::verb::get, '/status', [](const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        json::object response_json;
        response_json['status'] = 'Server is running!';
        
        // 设置响应
        res.result(http::status::ok);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    });
    
    // 注册POST /greet路由
    g_router.registerRoute(http::verb::post, '/greet', [](const http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res) {
        json::object response_json;
        
        try {
            // 解析请求体
            json::value parsed_body = json::parse(req.body());
            
            // 提取name字段
            std::string name = parsed_body.as_object()['name'].as_string().c_str();
            
            // 构造问候消息
            response_json['message'] = 'Hello, ' + name + '!';
        } catch (...) {
            // 错误处理
            response_json['error'] = 'Invalid JSON format.';
        }
        
        // 设置响应
        res.result(http::status::ok);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    });
    
    // 可以根据需要继续添加更多路由...
}


// Function to handle incoming HTTP requests and produce appropriate responses
void handle_request(
    http::request&lt;http::string_body&gt; req,         // Incoming HTTP request
    http::response&lt;http::string_body&gt;&amp; res        // Outgoing HTTP response (to be filled in)
) {
    // JSON object to hold the response body
    json::object response_json;

    // Log request information to the console for debugging
    std::cout &lt;&lt; 'Method: ' &lt;&lt; req.method() &lt;&lt; '...\n';
    std::cout &lt;&lt; 'Target: ' &lt;&lt; req.target() &lt;&lt; '...\n';
    std::cout &lt;&lt; 'Body: ' &lt;&lt; req.body() &lt;&lt; '...\n\n';

    // 尝试处理请求
    if (!g_router.handleRequest(req, res)) {
        // 如果路由管理器未处理请求，返回404 Not Found
        response_json['error'] = 'Unknown endpoint.';
        res.result(http::status::not_found);
        res.set(http::field::content_type, 'application/json');
        res.body() = json::serialize(response_json);
        res.prepare_payload();
    }
}


// 处理单个连接的函数
void handle_connection(tcp::socket socket) {
    try {
        beast::flat_buffer buffer;
        http::request&lt;http::string_body&gt; req;
        http::read(socket, buffer, req);

        http::response&lt;http::string_body&gt; res;
        handle_request(req, res);

        http::write(socket, res);
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; 'Connection error: ' &lt;&lt; e.what() &lt;&lt; '\n';
    }
}

// HTTP Server function
void run_server(asio::io_context&amp; ioc, unsigned short port, unsigned int thread_pool_size) {
     // 创建线程池
    asio::thread_pool pool(thread_pool_size);

    tcp::acceptor acceptor(ioc, tcp::endpoint(tcp::v4(), port));

    std::cout &lt;&lt; 'HTTP Server running on port ' &lt;&lt; port &lt;&lt; '...\n\n';

    while (true) {
        tcp::socket socket(ioc);
        acceptor.accept(socket);

        // 将连接处理任务提交到线程池
        asio::post(pool, [socket = std::move(socket)]() mutable {
            handle_connection(std::move(socket));
        });

        // beast::flat_buffer buffer;
        // http::request&lt;http::string_body&gt; req;
        // http::read(socket, buffer, req);

        // http::response&lt;http::string_body&gt; res;
        // handle_request(req, res);

        // http::write(socket, res);
    }
    std::cout &lt;&lt; 'Server shutting down, waiting for active connections...\n';
    // 等待所有线程池任务完成
    // 等待所有线程池任务完成
    pool.join();
    std::cout &lt;&lt; 'Server shutdown complete\n';
}

int main() {
    try {

        // 注册信号处理
        std::signal(SIGINT, signalHandler);
        std::signal(SIGTERM, signalHandler);

        // 初始化路由表
        initializeRoutes();
        asio::io_context io_context;
        //因为使用的是同步，所以不需要启动io_context的工作线程
        // // 启动io_context的工作线程
        // boost::thread io_thread([&amp;io_context]() {
        //     io_context.run();
        // });
        
        // 线程池大小可以根据CPU核心数或需求调整
        unsigned int thread_pool_size = std::thread::hardware_concurrency();
        if (thread_pool_size == 0)
            thread_pool_size = 4; // 默认值
        run_server(io_context, 8080, thread_pool_size);

        // 关闭io_context
        // io_context.stop();
        // if (io_thread.joinable()) {
        //     io_thread.join();
        // }

    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; 'Server error: ' &lt;&lt; e.what() &lt;&lt; '\n';
    }
    return 0;
}```。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/Boost%20Http-fu-wu-duan---tong-bu-fang-shi.html</guid><pubDate>Thu, 20 Nov 2025 02:12:26 +0000</pubDate></item><item><title>封装async_proc 异步任务处理</title><link>https://captain0005.github.io/captain/post/feng-zhuang-async_proc%20-yi-bu-ren-wu-chu-li.html</link><description>###封装代码
```
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include &lt;atomic&gt;

// 1. 定义你的信号量类（不变）
class vp_semaphore {
public:
    vp_semaphore() : count_(0) {}
    void signal() {
        std::unique_lock&lt;std::mutex&gt; lock(mutex_);
        ++count_;
        cv_.notify_one();
    }
    void wait() {
        std::unique_lock&lt;std::mutex&gt; lock(mutex_);
        cv_.wait(lock, [=] { return count_ &gt; 0; });
        --count_;
    }
private:
    std::mutex mutex_;
    std::condition_variable cv_;
    int count_;
};


class async_proc {
public:
    using Task = std::function&lt;void()&gt;;
    async_proc()
    {
        tid = std::thread([this]() {
            while (live) {
                semaphore_cv.wait();
                if (!live)
                    break;
                // std::lock_guard&lt;std::mutex&gt; lock(task_mtx); 可以不加 semaphore_cv中已经有对 task_que数量的判断
                if (task_que.empty()) {
                    continue;
                }
                auto tsk = task_que.front();
                task_que.pop();
                tsk();
            }
        });
    }
    ~async_proc()
    {
        live = false;
        semaphore_cv.signal();
        tid.join();
    }

    template &lt;typename F, typename... Args&gt; void post_task(F &amp;&amp;f, Args &amp;&amp;...args)
    {
        Task tsk = std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);
        std::lock_guard&lt;std::mutex&gt; lock(task_mtx);
        task_que.push(tsk);
        semaphore_cv.signal();
    }

    async_proc(const async_proc &amp;) = delete;
    async_proc &amp;operator=(const async_proc &amp;) = delete;

private:
    std::queue&lt;Task&gt; task_que;
    std::mutex task_mtx;
    //声明为原子变量，确保在多线程环境下的安全访问
    std::atomic&lt;bool&gt; live{true};
    std::thread tid;
    vp_semaphore semaphore_cv;
};
```

###使用示例
```
// 简单的函数示例
void print_hello() {
    std::cout &lt;&lt; 'Hello from thread! Thread ID: ' &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
}

// 带参数的函数示例
void print_message(const std::string&amp; message, int number) {
    std::cout &lt;&lt; 'Message: ' &lt;&lt; message &lt;&lt; ', Number: ' &lt;&lt; number 
              &lt;&lt; ' (Thread ID: ' &lt;&lt; std::this_thread::get_id() &lt;&lt; ')' &lt;&lt; std::endl;
}

// 带返回值的函数示例（在异步环境中返回值会被忽略，除非通过引用或指针传递）
void calculate_and_store(int a, int b, int&amp; result) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟耗时操作
    result = a + b;
    std::cout &lt;&lt; 'Calculated: ' &lt;&lt; a &lt;&lt; ' + ' &lt;&lt; b &lt;&lt; ' = ' &lt;&lt; result &lt;&lt; std::endl;
}

int main() {
    std::cout &lt;&lt; 'Main thread ID: ' &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    
    // 创建异步处理器实例
    async_proc processor;
    
    // 示例1：提交无参函数
    std::cout &lt;&lt; 'Submitting print_hello task...' &lt;&lt; std::endl;
    processor.post_task(print_hello);
    
    // 示例2：提交带参数的函数
    std::cout &lt;&lt; 'Submitting print_message task...' &lt;&lt; std::endl;
    processor.post_task(print_message, 'Async task', 42);
    
    // 示例3：提交Lambda表达式
    std::cout &lt;&lt; 'Submitting lambda task...' &lt;&lt; std::endl;
    processor.post_task([]() {
        std::cout &lt;&lt; 'Lambda executed! ' 
                  &lt;&lt; 'Current time: ' &lt;&lt; std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) &lt;&lt; std::endl;
    });
    
    // 示例4：提交带状态的任务（使用引用传递结果）
    int result = 0;
    std::cout &lt;&lt; 'Submitting calculation task...' &lt;&lt; std::endl;
    processor.post_task(calculate_and_store, 10, 32, std::ref(result));
    
    // 示例5：提交多个任务，展示并发执行
    std::cout &lt;&lt; 'Submitting multiple tasks...' &lt;&lt; std::endl;
    for (int i = 0; i &lt; 5; ++i) {
        processor.post_task([i]() {
            std::cout &lt;&lt; 'Batch task ' &lt;&lt; i &lt;&lt; ' executing...' &lt;&lt; std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50)); // 模拟不同的执行时间
            std::cout &lt;&lt; 'Batch task ' &lt;&lt; i &lt;&lt; ' completed.' &lt;&lt; std::endl;
        });
    }
    
    // 等待所有任务完成
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // 显示通过引用获取的计算结果
    std::cout &lt;&lt; 'Final result from calculation: ' &lt;&lt; result &lt;&lt; std::endl;
    
    std::cout &lt;&lt; 'Main function completed.' &lt;&lt; std::endl;
    return 0;
}
```。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/feng-zhuang-async_proc%20-yi-bu-ren-wu-chu-li.html</guid><pubDate>Wed, 19 Nov 2025 08:21:14 +0000</pubDate></item><item><title>c++ condition_variable 封装</title><link>https://captain0005.github.io/captain/post/c%2B%2B%20condition_variable%20-feng-zhuang.html</link><description>### 封装类
```

#include &lt;condition_variable&gt;
#include &lt;mutex&gt;

  // semaphore for queue/deque data structures in VideoPipe, used for producer-consumer pattern.
  // it blocks the consumer thread until data has come.
  class vp_semaphore
  {
  public:
      vp_semaphore() {
          count_ = 0;
      }

      void signal() {
          std::unique_lock&lt;std::mutex&gt; lock(mutex_);
          ++count_;
          cv_.notify_one();
      }

      void wait() {
          std::unique_lock&lt;std::mutex&gt; lock(mutex_);
          cv_.wait(lock, [=] { return count_ &gt; 0; });
          --count_;
      }

  private:
      std::mutex mutex_;
      std::condition_variable cv_;
      int count_;
  };

```
### 调用方法
**其他类中声明** ：vp_semaphore in_queue_semaphore;

&gt; 其他类的方法使用
生产者
// notify consumer of in_queue
in_queue_semaphore.signal();
消费者
// wait for producer, make sure in_queue is not empty.
in_queue_semaphore.wait();



。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/c%2B%2B%20condition_variable%20-feng-zhuang.html</guid><pubDate>Wed, 19 Nov 2025 03:25:54 +0000</pubDate></item><item><title>vscode配置Boost库</title><link>https://captain0005.github.io/captain/post/vscode-pei-zhi-Boost-ku.html</link><description>```
cmake_minimum_required(VERSION 3.16.3)
  project(testBoost VERSION 0.1.0)
  
  # 设置C++标准
  set(CMAKE_CXX_STANDARD 11)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  
  # 查找Boost库（不需要特定组件）
  #find_package(Boost REQUIRED)
  #if(Boost_FOUND)
  #    message('Boost found: ${Boost_VERSION}')
  #   include_directories(${Boost_INCLUDE_DIRS})
  #else()
  #    message(FATAL_ERROR 'Boost not found!')
  #endif()
  #需要thread和filessystem组件
  find_package(Boost REQUIRED COMPONENTS thread filesystem)
  if(Boost_FOUND)
      message('Boost found: ${Boost_VERSION}')
      include_directories(${Boost_INCLUDE_DIRS})
  else()
      message(FATAL_ERROR 'Boost not found!')
  endif()
  
  # 添加可执行文件
  add_executable(testBoost version.cpp)
  #对于仅标头库，您无需链接到已编译的 Boost 库。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/vscode-pei-zhi-Boost-ku.html</guid><pubDate>Tue, 18 Nov 2025 14:49:07 +0000</pubDate></item><item><title>Boost字符串操作</title><link>https://captain0005.github.io/captain/post/Boost-zi-fu-chuan-cao-zuo.html</link><description>```c++


    #include &lt;boost/algorithm/string.hpp&gt;
    #include &lt;boost/regex.hpp&gt;
    #include &lt;boost/filesystem.hpp&gt;

    std::string str = 'one,two,three,four'; 
    std::vector&lt;std::string&gt; result;
    boost::split(result, str, boost::is_any_of(','));

    for (const auto&amp; s : result) {
        std::cout &lt;&lt; s &lt;&lt; std::endl;
    }
    std::string str2 = 'Hello World,Hello World';
    boost::algorithm::replace_all(str2,'World','Boost');
    std::cout &lt;&lt; str2 &lt;&lt; std::endl; // 输出: Hello Boost,Hello Boost

    std::string str3 = '   Hello Boost   ';
    boost::trim(str3);
    std::cout &lt;&lt; str3 &lt;&lt; std::endl; //输出：Hello Boost
    
    std::string str4 = 'Hello World,Hello World';
    boost::replace_first(str4,'World','Boost');
    std::cout &lt;&lt; str4 &lt;&lt; std::endl; // 输出: Hello Boost,Hello World

    std::string str5 = 'Hello World,Hello World';
    boost::replace_last(str5,'World','Boost');
    std::cout &lt;&lt; str5 &lt;&lt; std::endl; // 输出: Hello World,Hello Boost

    std::string str6 = '2024-05-20 13:45:30';
    boost::regex date_regex('-');
    std::string result2 = boost::regex_replace(str6, date_regex, '/');
    std::cout &lt;&lt; result2 &lt;&lt; std::endl; // 输出: 2024/05/20 13:45:30

    std::string str7 = 'Apple banana apple orange APPLE,Apple,Apple,Apple';
    boost::replace_nth(str7,'Apple',3,'Banana');
    std::cout &lt;&lt; str7 &lt;&lt; std::endl; //输出 Apple banana apple orange APPLE,Apple,Apple,Banana
```。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/Boost-zi-fu-chuan-cao-zuo.html</guid><pubDate>Tue, 18 Nov 2025 14:47:14 +0000</pubDate></item><item><title>DeepSeek 多模态大模型 Janus-Pro 本地部署教程</title><link>https://captain0005.github.io/captain/post/DeepSeek%20-duo-mo-tai-da-mo-xing-%20Janus-Pro%20-ben-di-bu-shu-jiao-cheng.html</link><description># DeepSeek 多模态大模型 Janus-Pro 本地部署教程

## 下载模型仓库

 git clone https://github.com/deepseek-ai/Janus.git下载模型仓库
 
国内下载仓库失败时，可以使用以下代理：

git clone https://github.moeyy.xyz/https://github.com/deepseek-ai/Janus.git
准备 Conda 3.12 虚拟环境
conda create --name deepseek7B python=3.12

conda activate deepseek7B
Janus 安装基础依赖
cd Janus

## 安装基础依赖
pip install -e .

## 安装 gradio ui 界面
pip install gradio

## 启动带有gradio的ui界面，同时下载14GB+的大模型
python demo/app_januspro.py
启动成功后,在浏览器里输入：http://127.0.0.1:7860，即可访问 Gradio 页面。</description><guid isPermaLink="true">https://captain0005.github.io/captain/post/DeepSeek%20-duo-mo-tai-da-mo-xing-%20Janus-Pro%20-ben-di-bu-shu-jiao-cheng.html</guid><pubDate>Tue, 18 Nov 2025 14:45:31 +0000</pubDate></item></channel></rss>